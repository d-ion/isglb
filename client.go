package isglb

import (
	"context"
	"github.com/d-ion/stream"
	"github.com/sirupsen/logrus"
	"github.com/yindaheng98/execlock"
)

type ClientStreamFactory[S Status] interface {
	NewClientStream(ctx context.Context) (stream.ClientStream[Request, S], error)
}

type Client[S Status, R Report] struct {
	*stream.Client[Request, S]
	ctxTop    context.Context
	cancelTop context.CancelFunc

	sendStatusExec *execlock.SingleLatestExec

	cancelLast context.CancelFunc

	OnStatusRecv func(s Status)

	Logger *logrus.Logger
}

func NewClient[S Status, R Report](factory ClientStreamFactory[S]) *Client[S, R] {
	ctx, cancal := context.WithCancel(context.Background())
	c := &Client[S, R]{
		Client:         stream.NewClient[Request, S](factory),
		ctxTop:         ctx,
		cancelTop:      cancal,
		sendStatusExec: &execlock.SingleLatestExec{},
		Logger:         logrus.StandardLogger(),
	}
	c.OnMsgRecv(func(status S) {
		if c.OnStatusRecv != nil {
			c.OnStatusRecv(status)
		}
	})
	return c
}

// SendReport send the report, maybe lose when cannot connect
func (c *Client[S, R]) SendReport(report R) {
	c.DoWithClient(func(client stream.ClientStream[Request, S]) error {
		err := client.Send(&RequestReport{Report: report})
		if err != nil {
			c.Logger.Errorf("Report send error: %+v", err)
			return err
		}
		return nil
	})
}

// SendStatus send the Status, if there is a new status should be sent, the last send will be canceled
func (c *Client[S, R]) SendStatus(status S) {
	c.sendStatusExec.Do(func(ctx context.Context) {
		for {
			select {
			case <-c.ctxTop.Done():
				return
			case <-ctx.Done():
				return
			default:
			}
			ok := c.DoWithClient(func(client stream.ClientStream[Request, S]) error {
				err := client.Send(&RequestStatus{Status: status})
				if err != nil {
					c.Logger.Errorf("Status send error: %+v", err)
					return err
				}
				return nil
			})
			if ok {
				return
			}
		}
	})
}
